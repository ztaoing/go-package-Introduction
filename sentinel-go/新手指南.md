欢迎来到 Sentinel 的世界！这篇新手指南将指引您快速入门 Sentinel。

## 资源埋点

使用 Sentinel 的 `Entry` API 将业务逻辑封装起来，这一步称为“埋点”。每个埋点都有一个资源名称（resource），代表触发了这个资源的调用或访问。

## 规则配置

针对埋点资源配置相应的规则，来达到流量控制的效果。目前 Sentinel Golang 支持流控规则 (FlowRule) 和系统保护规则 (SystemRule)。

## 一个完整的示例

```go
import (
	sentinel "github.com/alibaba/sentinel-golang/api"
)

func main() {
	// 务必先进行初始化
	err := sentinel.InitDefault()
	if err != nil {
		log.Fatal(err)
	}

	// 配置一条限流规则
	_, err = flow.LoadRules([]*flow.FlowRule{
		{
			Resource:          "some-test",
			MetricType:        flow.QPS,
			Count:             10,
			ControlBehavior:   flow.Reject,
		},
	})
	if err != nil {
		fmt.Println(err)
		return
	}

	ch := make(chan struct{})
	for i := 0; i < 10; i++ {
		go func() {
			for {
				// 埋点逻辑，埋点资源名为 some-test
				e, b := sentinel.Entry("some-test")
				if b != nil {
					// 请求被拒绝，在此处进行处理
					time.Sleep(time.Duration(rand.Uint64() % 10) * time.Millisecond)
				} else {
					// 请求允许通过，此处编写业务逻辑
					fmt.Println(util.CurrentTimeMillis(), "Passed")
					time.Sleep(time.Duration(rand.Uint64() % 10) * time.Millisecond)

					// 务必保证业务结束后调用 Exit
					e.Exit()
				}

			}
		}()
	}
	<-ch
}
```

Demo 运行后，可以看到控制台每秒稳定输出 "Passed" 10 次，和规则中预先设定的阈值是一样的。我们可以在 metric 日志里看到类似下面的输出：

```
1581516234000|2020-02-12 22:03:54|some-test|10|2068|10|0|5|0|0|0
1581516235000|2020-02-12 22:03:55|some-test|10|2073|10|0|3|0|0|0
1581516236000|2020-02-12 22:03:56|some-test|10|2058|10|0|5|0|0|0
1581516237000|2020-02-12 22:03:57|some-test|10|2023|10|0|5|0|0|0
1581516238000|2020-02-12 22:03:58|some-test|10|2046|10|0|5|0|0|0
```

其中 `some-test` 这一列代表埋点资源名，后面的数字依次代表该一秒内的通过数（pass）、拒绝数（block）、完成数（complete）、错误数目（error）、平均响应时长（rt）。详细信息可以参考 [监控日志文档](https://github.com/alibaba/sentinel-golang/wiki/实时监控#秒级监控日志)。

