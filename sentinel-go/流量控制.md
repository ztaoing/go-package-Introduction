## 流控规则

一条流控规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：

- `Resource`：资源名，即规则的作用目标
- `MetricType`: 指标类型
- `Count`: 流控阈值
- `RelationStrategy`: 调用关系限流策略
- `ControlBehavior`: 流量控制效果（直接拒绝、Warm Up、匀速排队等）

## 流控指标

目前支持的流控指标：

- QPS
- 并发数（用于信号量隔离）

## 流量控制效果

流控效果对应流控规则中的 `ControlBehavior` 字段。目前支持直接拒绝和匀速排队这几种控制效果。

### 直接拒绝

Sentinel 默认的流控效果是直接拒绝（`Reject`）。当前的请求量超过对应规则的阈值后，新的请求就会被立即拒绝。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。

### 匀速排队

匀速排队（`Throttling`）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。多余的请求可以排队等待而不是立即拒绝。详细文档可以参考 [流量控制 - 匀速器模式](https://github.com/alibaba/Sentinel/wiki/流量控制-匀速排队模式)。

该方式的作用如下图所示：

![queueing](https://github.com/alibaba/Sentinel/wiki/image/uniform-speed-queue.png)

这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。

以下规则代表每 100ms 最多通过一个请求，多余的请求将会排队等待通过，若排队时队列长度大于 500ms 则直接拒绝：

```go
{
	Resource:          "some-test",
	MetricType:        flow.QPS,
	Count:             10, // 请求的间隔控制在 1000/10=100 ms
	ControlBehavior:   flow.Throttling, // 流控效果为匀速排队
	MaxQueueingTimeMs: 500, // 最长排队等待时间
}
```

`MaxQueueingTimeMs` 设为 0 时代表不允许排队，只控制请求时间间隔，多余的请求将会直接拒绝。

## 基于调用关系的流量控制

Sentinel 支持关联流量控制策略。当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢。